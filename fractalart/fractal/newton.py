"""An implementation of Newton fractal."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/fractals/04_newton.ipynb.

# %% auto 0
__all__ = ['Fractal', 'smooth_coloring', 'mandelbrot_step_1', 'mandelbrot_step_3', 'mandelbrot_step_4', 'mandelbrot_step_5',
           'mandelbrot_step_n', 'mandelbrot_step', 'julia_step', 'cross_dist', 'newton_step', 'newton_fn',
           'newton_derivative_fn', 'compute_roots_of_unity', 'Mandelbrot', 'MandelbrotCrossTrap', 'Newton']

# %% ../../nbs/fractals/04_newton.ipynb 4
from abc import abstractmethod
import numpy as np
from ..core import Image
from numba import njit, prange, jit
import math
import matplotlib.pyplot as plt

# %% ../../nbs/fractals/04_newton.ipynb 5
class Fractal(Image):
    """Abstract base class for generating fractal images."""

    @abstractmethod
    def compute(self) -> np.ndarray:
        """Abstract method to compute the fractal array. Must be implemented by subclasses."""
        pass

    @property
    def max_iter(self) -> int:
        """Maximum number of iterations used in fractal computation."""
        return self._max_iter

    @max_iter.setter
    def max_iter(self, value: int):
        if value <= 0:
            raise ValueError("max_iter must be a positive integer.")
        self._max_iter = value

    def plot(self, cmap: str = "turbo"):
        """Display the rendered fractal image using matplotlib."""
        # TODO : Us lighter image plotting, e. g. using PIL.Image or cv2
        plt.figure(figsize=(8, 8))
        plt.imshow(
            self._image,
            cmap=cmap,
            extent=[self._x_min, self._x_max, self._y_min, self._y_max],
            origin='lower'
        )
        plt.axis('off')
        plt.show()
    
    def set_zoom(self, zoom: float, center: tuple[float, float]):
        """
        Zoom into the fractal at a specific center.

        Args:
            zoom: Zoom factor (higher is closer).
            center: (x, y) center coordinates in the complex plane.
        """
        if zoom <= 0:
            raise ValueError("zoom must be a positive number.")
        cx, cy = center
        delta = (self._x_max - self._x_min) / (2 * zoom)
        self._x_min, self._x_max = cx - delta, cx + delta
        self._y_min, self._y_max = cy - delta, cy + delta

    def _render(self):
        """Generate and store the fractal image using the subclass-defined `compute` method."""
        self._image = self.compute()

# %% ../../nbs/fractals/04_newton.ipynb 6
@njit(parallel=True, fastmath=True)
def _compute_fractal(x_min: float, x_max: float, y_min: float, y_max: float, resolution: tuple[int, int],
                     max_iter: int, fractal_fn, order: int = 1, smooth: bool = True) -> np.ndarray:
    
    width, height = resolution
    result = np.zeros((height, width), dtype=np.float64)
    r2_cut = max(abs(x_max), abs(x_min)) * max(abs(x_max), abs(x_min)) + max(abs(y_max), abs(y_min)) * max(abs(y_max), abs(y_min))

    dx = (x_max - x_min) / (width - 1)
    dy = (y_max - y_min) / (height - 1)
    inv_log2 = 1.0 / math.log(2.0)

    for j in prange(height):
        zy = y_min + j * dy
        for i in range(width):
            zx = x_min + i * dx
            zr = 0.0
            zi = 0.0
            cr = zx
            ci = zy
            iteration = 0

            while zr * zr + zi * zi <= r2_cut and iteration < max_iter:
                zr, zi = fractal_fn(zr, zi, cr, ci, order)
                iteration += 1

            if smooth and iteration < max_iter:
                result[j, i] = smooth_coloring(zr, zi, iteration)
            else:
                result[j, i] = iteration

    return result

# %% ../../nbs/fractals/04_newton.ipynb 7
_inv_log2 = 1.0 / math.log(2.0)

#@njit
#def smooth_coloring(zr, zi, iteration):
#    mag_sq = zr * zr + zi * zi
#    if mag_sq > 0.0:
#        log_zn = 0.5 * math.log(mag_sq)
#        if log_zn > 0.0:
#            nu = math.log(log_zn * _inv_log2) * _inv_log2
#            return iteration + 1 - nu
#        else:
#            return iteration
#    else:
#        return iteration
@njit
def smooth_coloring(zr, zi, iteration):
    mag_sq = zr * zr + zi * zi

    # Ensure mag_sq > 1 to avoid log(â‰¤0)
    if mag_sq > 1e-8:
        log_zn = 0.5 * math.log(mag_sq)
        if log_zn > 1e-8:
            nu = math.log(log_zn * _inv_log2) * _inv_log2
            return iteration + 1 - nu

    return float(iteration)

@njit
def mandelbrot_step_1(zr, zi, cr, ci):
    zr2 = zr * zr
    zi2 = zi * zi
    zr_new = zr2 - zi2 + cr
    zi_new = 2.0 * zr * zi + ci
    return zr_new, zi_new

@njit
def mandelbrot_step_3(zr, zi, cr, ci):
    zr2 = zr * zr
    zi2 = zi * zi
    zr3 = zr2 * zr
    zi3 = zi2 * zi
    zr_new = zr3 - 3.0 * zr * zi2 + cr
    zi_new = 3.0 * zr2 * zi - zi3 + ci
    return zr_new, zi_new

@njit
def mandelbrot_step_4(zr, zi, cr, ci):
    zr2 = zr * zr
    zi2 = zi * zi
    zr4 = zr2 * zr2
    zi4 = zi2 * zi2
    zr2zi2 = zr2 * zi2
    zr_new = zr4 - 6.0 * zr2zi2 + zi4 + cr
    zi_new = 4.0 * zr * zi * (zr2 - zi2) + ci
    return zr_new, zi_new

@njit
def mandelbrot_step_5(zr, zi, cr, ci):
    zr2 = zr * zr
    zi2 = zi * zi
    zr3 = zr2 * zr
    zi3 = zi2 * zi
    zr4 = zr3 * zr
    zi4 = zi3 * zi
    zr5 = zr4 * zr
    zi5 = zi4 * zi
    zrzi = zr * zi
    zrzi3 = zrzi * zi2  # zr * zi^3
    zr3zi = zr3 * zi    # zr^3 * zi
    zrzi3 = zr * zi3    # zr * zi^3
    zr_new = zr5 - 10.0 * zr3 * zi2 + 5.0 * zr * zi4 + cr
    zi_new = 5.0 * zr4 * zi - 10.0 * zr2 * zi3 + zi5 + ci
    return zr_new, zi_new

@njit
def mandelbrot_step_n(zr, zi, cr, ci, n):
    z = complex(zr, zi)
    c = complex(cr, ci)
    z = z ** n + c
    return z.real, z.imag

@njit
def mandelbrot_step(zr, zi, cr, ci, n):
    if n == 2:
        return mandelbrot_step_1(zr, zi, cr, ci)
    elif n == 3:
        return mandelbrot_step_3(zr, zi, cr, ci)
    elif n == 4:
        return mandelbrot_step_4(zr, zi, cr, ci)
    elif n == 5:
        return mandelbrot_step_5(zr, zi, cr, ci)
    else:
        return mandelbrot_step_n(zr, zi, cr, ci, n)

@njit
def julia_step(zr, zi, cr, ci):
    return mandelbrot_step(zr, zi, cr, ci)

@njit
def cross_dist(zr: float, zi: float) -> float:
    return min(abs(zr), abs(zi))

@njit
def newton_step(zr, zi, cr, ci, order, fractal_fn, fractal_derivative_fn):
    """
    Perform one Newton iteration step on complex z = zr + i*zi:
    z_next = z - f(z) / f'(z)
    
    Parameters:
        zr, zi : float - real and imaginary parts of current z
        cr, ci : float - parameters (e.g., constants in fractal)
        order : int - order of fractal
        fractal_fn : function - f(z), returns (fr, fi)
        fractal_derivative_fn : function - f'(z), returns (dr, di)
        
    Returns:
        (zr_next, zi_next): next iteration complex number
    """
    # Compute f(z)
    fr, fi = newton_fn(zr, zi, cr, ci, order)
    # Compute f'(z)
    dr, di = newton_derivative_fn(zr, zi, cr, ci, order)
    
    # Compute denominator = |f'(z)|^2
    denom = dr*dr + di*di
    if denom == 0.0:
        # Avoid division by zero - just return current z
        return zr, zi
    
    # Complex division (f / f') = (fr + i fi) / (dr + i di)
    # (a+bi)/(c+di) = ((ac+bd) + i(bc - ad)) / (c^2 + d^2)
    real_part = (fr*dr + fi*di) / denom
    imag_part = (fi*dr - fr*di) / denom
    
    # Newton step: z_next = z - f(z)/f'(z)
    zr_next = zr - real_part
    zi_next = zi - imag_part
    
    return zr_next, zi_next

@njit
def newton_fn(zr, zi, cr, ci, order):
    """
    Compute f(z) = z^order - 1
    where z = zr + i zi
    
    Returns: (fr, fi) real and imaginary parts of f(z)
    """
    # Compute z^order
    zr_pow = 1.0
    zi_pow = 0.0
    for _ in range(order):
        # multiply (zr_pow + i zi_pow) * (zr + i zi)
        temp = zr_pow * zr - zi_pow * zi
        zi_pow = zr_pow * zi + zi_pow * zr
        zr_pow = temp
    
    # f(z) = z^order - 1
    fr = zr_pow - 1.0
    fi = zi_pow
    
    return fr, fi


@njit
def newton_derivative_fn(zr, zi, cr, ci, order):
    """
    Compute f'(z) = order * z^(order - 1)
    where z = zr + i zi
    
    Returns: (dr, di) real and imaginary parts of f'(z)
    """
    if order == 1:
        # derivative of z^1 - 1 is 1
        return 1.0, 0.0
    
    # Compute z^(order - 1)
    zr_pow = 1.0
    zi_pow = 0.0
    for _ in range(order - 1):
        # multiply (zr_pow + i zi_pow) * (zr + i zi)
        temp = zr_pow * zr - zi_pow * zi
        zi_pow = zr_pow * zi + zi_pow * zr
        zr_pow = temp
    
    # Multiply by order
    dr = order * zr_pow
    di = order * zi_pow
    
    return dr, di

@njit
def compute_roots_of_unity(order):
    roots_real = np.empty(order, dtype=np.float64)
    roots_imag = np.empty(order, dtype=np.float64)
    for k in range(order):
        angle = 2.0 * math.pi * k / order
        roots_real[k] = math.cos(angle)
        roots_imag[k] = math.sin(angle)
    return roots_real, roots_imag

# %% ../../nbs/fractals/04_newton.ipynb 8
class Mandelbrot(Fractal):
    def __init__(
        self,
        x_min: float = -2.5,
        x_max: float = 1.5,
        y_min: float = -2.0,
        y_max: float = 2.0,
        width: int = 600,
        height: int = 600,
        max_iter: int = 200,
        order: int = 2
    ):
        """Initialize the fractal with image resolution and complex plane bounds."""
        self._x_min, self._x_max = x_min, x_max
        self._y_min, self._y_max = y_min, y_max
        self.resolution = width, height
        self.max_iter = max_iter
        self._order = order
        
    def compute(self) -> np.ndarray:
        w, h = self.resolution
        return _compute_fractal(self._x_min, self._x_max, self._y_min, self._y_max,
                                self.resolution, self._max_iter, mandelbrot_step, self._order)

# %% ../../nbs/fractals/04_newton.ipynb 10
@njit(parallel=True, fastmath=True)
def _compute_orbit_trap(x_min, x_max, y_min, y_max, resolution,
                        max_iter, fractal_fn, order, orbit_trap_fn):

    width, height = resolution
    result = np.zeros((height, width), dtype=np.float64)
    dx = (x_max - x_min) / (width - 1)
    dy = (y_max - y_min) / (height - 1)

    for j in prange(height):
        zy = y_min + j * dy
        for i in range(width):
            zx = x_min + i * dx
            zr = 0.0
            zi = 0.0
            cr = zx
            ci = zy
            iteration = 0
            min_cross = np.inf  # Use a proper "initial max"

            while iteration < max_iter:
                zr, zi = fractal_fn(zr, zi, cr, ci, order)
                iteration += 1

                # needed for fastmath = True in njit
                if math.isnan(zr) or math.isnan(zi) or math.isinf(zr) or math.isinf(zi):
                    break  # Or handle differently

                if iteration > 1:
                    dist = orbit_trap_fn(zr, zi)
                    if dist < min_cross:
                        min_cross = dist

            result[j, i] = min_cross

    return result

# %% ../../nbs/fractals/04_newton.ipynb 11
class MandelbrotCrossTrap(Fractal):
    def __init__(
        self,
        x_min: float = -2.5,
        x_max: float = 1.5,
        y_min: float = -2.0,
        y_max: float = 2.0,
        width: int = 600,
        height: int = 600,
        max_iter: int = 200,
        order: int = 2
    ):
        """Initialize the fractal with image resolution and complex plane bounds."""
        self._x_min, self._x_max = x_min, x_max
        self._y_min, self._y_max = y_min, y_max
        self.resolution = width, height
        self.max_iter = max_iter
        self._order = order
        
    def compute(self) -> np.ndarray:
        w, h = self.resolution
        return _compute_orbit_trap(self._x_min, self._x_max, self._y_min, self._y_max,
                                self.resolution, self._max_iter, mandelbrot_step, self._order, cross_dist)

# %% ../../nbs/fractals/04_newton.ipynb 14
class Newton(Fractal):
    def __init__(
        self,
        x_min: float = -2.0,
        x_max: float = 2.0,
        y_min: float = -2.0,
        y_max: float = 2.0,
        width: int = 600,
        height: int = 600,
        max_iter: int = 200,
        order: int = 3
    ):
        """Initialize the fractal with image resolution and complex plane bounds."""
        self._x_min, self._x_max = x_min, x_max
        self._y_min, self._y_max = y_min, y_max
        self.resolution = width, height
        self.max_iter = max_iter
        self._order = order
        
    def compute(self) -> np.ndarray:
        w, h = self.resolution
        return _compute_newton(self._x_min, self._x_max, self._y_min, self._y_max, self.resolution, self.max_iter,
                               self._order, newton_fn, newton_derivative_fn)
