"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/fractals/01_fractal.ipynb.

# %% auto 0
__all__ = ['Fractal', 'compute_mandelbrot', 'Mandelbrot']

# %% ../nbs/fractals/01_fractal.ipynb 4
from abc import abstractmethod
import numpy as np
from .core import Image
from numba import jit, prange
import math
import matplotlib.pyplot as plt

# %% ../nbs/fractals/01_fractal.ipynb 5
class Fractal(Image):
    def __init__(self, x_min: float = -2.0, x_max: float = 1.0, y_min: float = -1.5, y_max: float = 1.5, max_iter: int = 1000):
        self._x_min = x_min
        self._x_max = x_max
        self._y_min = y_min
        self._y_max = y_max
        if max_iter <= 0:
            raise ValueError("max_iter and height must be positive integers.")
        self._max_iter = max_iter

    @abstractmethod
    def compute(self) -> np.ndarray:
        pass

    @property
    def max_iter(self) -> int:
        return self._max_iter

    @max_iter.setter
    def max_iter(self, value: int):
        if value <= 0:
            raise ValueError("max_iter must be a positive integer.")
        self._max_iter = value

    def plot(self, cmap: str = "turbo"):
        """Plot the rendered image using matplotlib."""
        plt.figure(figsize=(10, 10))
        plt.imshow(self._image, cmap=cmap, extent=[self._x_min, self._x_max, self._y_min, self._y_max])
        plt.show()

    def set_zoom(self, zoom: float, center: tuple[float, float]):
        delta = 2 / zoom
        self._x_min, self._y_min = center[0] - delta, center[1] - delta
        self._x_max, self._y_max = center[0] + delta, center[1] + delta

    def _render(self) -> np.ndarray:
        width, height = self.resolution
        return self.compute()

# %% ../nbs/fractals/01_fractal.ipynb 6
@jit(nopython=True, parallel=True, fastmath=True)
def compute_mandelbrot(x_min, x_max, y_min, y_max, width, height, max_iter):
    result = np.zeros((height, width), dtype=float)

    scale_x = (x_max - x_min) / width
    scale_y = (y_max - y_min) / height

    log2 = math.log(2.0)

    for y in prange(height):
        zy = y_min + y * scale_y
        for x in range(width):
            zx = x_min + x * scale_x
            zr, zi = 0.0, 0.0
            cr, ci = zx, zy
            n = 0

            while zr * zr + zi * zi <= 4.0 and n < max_iter:
                zr2 = zr * zr - zi * zi + cr
                zi = 2.0 * zr * zi + ci
                zr = zr2
                n += 1

            if n < max_iter:
                mag_sq = zr * zr + zi * zi
                log_zn = 0.5 * math.log(mag_sq)
                nu = math.log(log_zn / log2) / log2
                result[y, x] = n + 1 - nu
            else:
                result[y, x] = n
    return result


class Mandelbrot(Fractal):
    def compute(self):
        width, height = self.resolution
        self._image = compute_mandelbrot(self._x_min, self._x_max, self._y_min, self._y_max, self._width, self._height, self._max_iter)

