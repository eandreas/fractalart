[
  {
    "objectID": "fractals/julia.html",
    "href": "fractals/julia.html",
    "title": "julia",
    "section": "",
    "text": "source\n\njulia_step\n\n julia_step (zr, zi, cr, ci)\n\n\nsource\n\n\nsmooth_coloring\n\n smooth_coloring (zr, zi, iteration)\n\n\nclass Julia(Fractal):\n    def __init__(\n        self,\n        x_min: float = None,\n        x_max: float =  None,\n        y_min: float = None,\n        y_max: float =  None,\n        cr: float = -0.7,\n        ci: float = 0.27015,\n        width: int = 600,\n        height: int = 600,\n        max_iter: int = 200,\n    ):\n        if None in (x_min, x_max, y_min, y_max):\n            x_min, x_max, y_min, y_max = -1.5, 1.5, -1.5, 1.5\n        self._x_min, self._x_max = x_min, x_max\n        self._y_min, self._y_max = y_min, y_max\n        self.resolution = width, height\n        self.max_iter = max_iter\n        self._cr = cr\n        self._ci = ci\n        \n    def compute(self) -&gt; np.ndarray:\n        return _compute_julia(self._x_min, self._x_max, self._y_min, self._y_max, self._cr, self._ci, \n                                self.resolution, self._max_iter, julia_step)\n\n\nj = Julia()\nj.render()\nj.equalize_histogram()\nj.plot()\n\n\n---------------------------------------------------------------------------\nTypingError                               Traceback (most recent call last)\nCell In[8], line 2\n      1 j = Julia()\n----&gt; 2 j.render()\n      3 j.equalize_histogram()\n      4 j.plot()\n\nFile ~/projects/dev/fractalart/fractalart/core.py:49, in Image.render(self)\n     47 \"\"\"Render the image using subclass-defined logic.\"\"\"\n     48 before = self._image.copy()\n---&gt; 49 self._render()\n     50 if np.array_equal(before, self._image):\n     51     raise RuntimeError(\"Subclasses must modify self._image during rendering.\")\n\nFile ~/projects/dev/fractalart/fractalart/fractal/abstract_fractal.py:85, in Fractal._render(self)\n     83 def _render(self):\n     84     \"\"\"Generate and store the fractal image using the subclass-defined `compute` method.\"\"\"\n---&gt; 85     self._image = self.compute()\n\nCell In[7], line 24, in Julia.compute(self)\n     23 def compute(self) -&gt; np.ndarray:\n---&gt; 24     return _compute_julia(self._x_min, self._x_max, self._y_min, self._y_max, self._cr, self._ci, \n     25                             self.resolution, self._max_iter, julia_step)\n\nFile ~/miniconda3/envs/art/lib/python3.11/site-packages/numba/core/dispatcher.py:424, in _DispatcherBase._compile_for_args(self, *args, **kws)\n    420         msg = (f\"{str(e).rstrip()} \\n\\nThis error may have been caused \"\n    421                f\"by the following argument(s):\\n{args_str}\\n\")\n    422         e.patch_message(msg)\n--&gt; 424     error_rewrite(e, 'typing')\n    425 except errors.UnsupportedError as e:\n    426     # Something unsupported is present in the user code, add help info\n    427     error_rewrite(e, 'unsupported_error')\n\nFile ~/miniconda3/envs/art/lib/python3.11/site-packages/numba/core/dispatcher.py:365, in _DispatcherBase._compile_for_args.&lt;locals&gt;.error_rewrite(e, issue_type)\n    363     raise e\n    364 else:\n--&gt; 365     raise e.with_traceback(None)\n\nTypingError: Failed in nopython mode pipeline (step: nopython frontend)\nNameError: name 'r4' is not defined\nDuring: Pass nopython_type_inference",
    "crumbs": [
      "fractals",
      "julia"
    ]
  },
  {
    "objectID": "fractals/mandelbrot.html",
    "href": "fractals/mandelbrot.html",
    "title": "mandelbrot",
    "section": "",
    "text": "source\n\nmandelbrot_step\n\n mandelbrot_step (zr, zi, cr, ci, n)\n\n\nsource\n\n\nmandelbrot_step_n\n\n mandelbrot_step_n (zr, zi, cr, ci, n)\n\n\nsource\n\n\nmandelbrot_step_5\n\n mandelbrot_step_5 (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step_4\n\n mandelbrot_step_4 (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step_3\n\n mandelbrot_step_3 (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step_1\n\n mandelbrot_step_1 (zr, zi, cr, ci)\n\n\nsource\n\n\nsmooth_coloring\n\n smooth_coloring (zr, zi, iteration)\n\n\nsource\n\n\nMandelbrot\n\n Mandelbrot (x_min:float=None, x_max:float=None, y_min:float=None,\n             y_max:float=None, width:int=600, height:int=600,\n             max_iter:int=200, order:int=2)\n\nAbstract base class for generating fractal images.\n\nm = Mandelbrot()\na = m.render()\nm.equalize_histogram()\nm.plot()\n\n\n\n\n\n\n\n\n\nm = Mandelbrot(order=7)\na = m.render()\nm.equalize_histogram()\nm.plot()",
    "crumbs": [
      "fractals",
      "mandelbrot"
    ]
  },
  {
    "objectID": "core/image.html",
    "href": "core/image.html",
    "title": "image",
    "section": "",
    "text": "source\n\nImage\n\n Image (width:int=1200, height:int=1200)\n\nAbstract base class for image rendering and manipulation.",
    "crumbs": [
      "core",
      "image"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fractalart",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "fractalart"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "fractalart",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall fractalart in Development mode\n# make sure fractalart package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to fractalart\n$ nbdev_prepare",
    "crumbs": [
      "fractalart"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "fractalart",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/eandreas/fractalart.git\nor from conda\n$ conda install -c eandreas fractalart\nor from pypi\n$ pip install fractalart\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "fractalart"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "fractalart",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2\n\n\n\nm = Mandelbrot()\nm.render()\nm.equalize_histogram()\nm.plot()\n\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.",
    "crumbs": [
      "fractalart"
    ]
  },
  {
    "objectID": "fractals/newton.html",
    "href": "fractals/newton.html",
    "title": "newton",
    "section": "",
    "text": "source\n\nFractal\n\n Fractal (width:int=1200, height:int=1200)\n\nAbstract base class for generating fractal images.\n\nsource\n\n\ncompute_roots_of_unity\n\n compute_roots_of_unity (order)\n\n\nsource\n\n\nnewton_derivative_fn\n\n newton_derivative_fn (zr, zi, cr, ci, order)\n\nCompute f’(z) = order  z^(order - 1) where z = zr + i zi\nReturns: (dr, di) real and imaginary parts of f’(z)*\n\nsource\n\n\nnewton_fn\n\n newton_fn (zr, zi, cr, ci, order)\n\n*Compute f(z) = z^order - 1 where z = zr + i zi\nReturns: (fr, fi) real and imaginary parts of f(z)*\n\nsource\n\n\nnewton_step\n\n newton_step (zr, zi, cr, ci, order, fractal_fn, fractal_derivative_fn)\n\nPerform one Newton iteration step on complex z = zr + izi: z_next = z - f(z) / f’(z)\nParameters: zr, zi : float - real and imaginary parts of current z cr, ci : float - parameters (e.g., constants in fractal) order : int - order of fractal fractal_fn : function - f(z), returns (fr, fi) fractal_derivative_fn : function - f’(z), returns (dr, di)\nReturns: (zr_next, zi_next): next iteration complex number*\n\nsource\n\n\ncross_dist\n\n cross_dist (zr:float, zi:float)\n\n\nsource\n\n\njulia_step\n\n julia_step (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step\n\n mandelbrot_step (zr, zi, cr, ci, n)\n\n\nsource\n\n\nmandelbrot_step_n\n\n mandelbrot_step_n (zr, zi, cr, ci, n)\n\n\nsource\n\n\nmandelbrot_step_5\n\n mandelbrot_step_5 (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step_4\n\n mandelbrot_step_4 (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step_3\n\n mandelbrot_step_3 (zr, zi, cr, ci)\n\n\nsource\n\n\nmandelbrot_step_1\n\n mandelbrot_step_1 (zr, zi, cr, ci)\n\n\nsource\n\n\nsmooth_coloring\n\n smooth_coloring (zr, zi, iteration)\n\n\nsource\n\n\nMandelbrot\n\n Mandelbrot (x_min:float=-2.5, x_max:float=1.5, y_min:float=-2.0,\n             y_max:float=2.0, width:int=600, height:int=600,\n             max_iter:int=200, order:int=2)\n\nAbstract base class for generating fractal images.\n\nm = Mandelbrot(order=2)\nm.resolution = 600, 600\nm.max_iter = 200\na = m.render()\nm.equalize_histogram()\nm.plot()\n\nOMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n\n\n\n\n\n\n\n\n\n\nsource\n\n\nMandelbrotCrossTrap\n\n MandelbrotCrossTrap (x_min:float=-2.5, x_max:float=1.5, y_min:float=-2.0,\n                      y_max:float=2.0, width:int=600, height:int=600,\n                      max_iter:int=200, order:int=2)\n\nAbstract base class for generating fractal images.\n\nm = MandelbrotCrossTrap(order=2)\nm.resolution = 1200, 1200\nm.max_iter = 200\nm.render()\nm.equalize_histogram()\nm.plot()\n\n\n\n\n\n\n\n\n\n@njit(parallel=True)\ndef _compute_newton(x_min, x_max, y_min, y_max, resolution, max_iter, order, fractal_fn, fractal_derivative_fn):\n    width, height = resolution\n    result = np.zeros((height, width), dtype=np.int32)\n    dx = (x_max - x_min) / (width - 1)\n    dy = (y_max - y_min) / (height - 1)\n\n    roots_real, roots_imag = compute_roots_of_unity(order)\n\n    for j in prange(height):\n        zy = y_min + j * dy\n        for i in range(width):\n            zx = x_min + i * dx\n            zr, zi = zx, zy\n            converged = False\n            for iteration in range(max_iter):\n                # fractal_fn and fractal_derivative_fn assumed njit and defined elsewhere\n                fr, fi = fractal_fn(zr, zi, 0.0, 0.0, order)\n                dr, di = fractal_derivative_fn(zr, zi, 0.0, 0.0, order)\n\n                denom = dr*dr + di*di\n                if denom == 0.0:\n                    break\n\n                real_part = (fr*dr + fi*di) / denom\n                imag_part = (fi*dr - fr*di) / denom\n\n                zr -= real_part\n                zi -= imag_part\n\n                # Check convergence to any root\n                for root_index in range(order):\n                    dist = (zr - roots_real[root_index])**2 + (zi - roots_imag[root_index])**2\n                    if dist &lt; 1e-6:\n                        result[j, i] = root_index + 1\n                        converged = True\n                        break\n\n                if converged:\n                    break\n\n    return result\n\n\nsource\n\n\nNewton\n\n Newton (x_min:float=-2.0, x_max:float=2.0, y_min:float=-2.0,\n         y_max:float=2.0, width:int=600, height:int=600, max_iter:int=200,\n         order:int=3)\n\nAbstract base class for generating fractal images.\n\nfractal = Newton()\nfractal.render()\n#fractal.equalize_histogram()\nfractal.plot()\n\n\n\n\n\n\n\n\n\n##| export\n#@njit(parallel=True, fastmath=True)\n#def _compute_mandelbrot(x_min: float, x_max: float, y_min: float, y_max: float, width: int, height: int, max_iter: int) -&gt; np.ndarray:\n#    # Allocate with float32 to halve memory bandwidth (optional)\n#    result = np.zeros((height, width), dtype=np.float32)\n#\n#    dx = (x_max - x_min) / (width - 1)\n#    dy = (y_max - y_min) / (height - 1)\n#\n#    inv_log2 = 1.0 / math.log(2.0)   # for nu calculation\n#    r2_cut = max(abs(x_max), abs(x_min)) * max(abs(x_max), abs(x_min)) + max(abs(y_max), abs(y_min)) * max(abs(y_max), abs(y_min))\n#\n#    for j in prange(height):\n#        zy = y_min + j * dy\n#        for i in range(width):\n#            zx = x_min + i * dx\n#            zr = 0.0\n#            zi = 0.0\n#            cr = zx\n#            ci = zy\n#            iteration = 0\n#\n#            # Mandelbrot iteration\n#            while zr * zr + zi * zi &lt;= r2_cut and iteration &lt; max_iter:\n#                # TODO : use zr * zr + zi * zi &lt;= 4 and iteration &lt; max_iter for classical fractal calculation without orbit traps\n#                # (zr + i zi)^2 + c\n#                zr2 = zr * zr - zi * zi + cr\n#                zi = 2.0 * zr * zi + ci\n#                zr = zr2\n#                iteration += 1\n#\n#            if iteration &lt; max_iter:\n#                mag_sq = zr * zr + zi * zi\n#                if mag_sq &gt; 0.0:\n#                    log_zn = 0.5 * math.log(mag_sq)\n#                    if log_zn &gt; 0.0:\n#                        nu = math.log(log_zn * inv_log2) * inv_log2\n#                        result[j, i] = iteration + 1 - nu\n#                    else:\n#                        result[j, i] = iteration\n#                else:\n#                    result[j, i] = iteration\n#            else:\n#                result[j, i] = iteration\n#\n#    return result\n#\n#class Mandelbrot(Fractal):\n#    def compute(self) -&gt; np.ndarray:\n#        w, h = self.resolution\n#        # pass resolution-consistent dims\n#        return _compute_mandelbrot(self._x_min, self._x_max, self._y_min, self._y_max, w, h, self._max_iter)\n\n\n##| export\n#@njit(parallel=True, fastmath=True)\n#def _compute_mandelbrot_cross_trap(x_min: float, x_max: float, y_min: float, y_max: float, width: int, height: int, max_iter: int) -&gt; np.ndarray:\n#    # Allocate with float32 to halve memory bandwidth (optional)\n#    cross_trap = np.zeros((height, width), dtype=np.float32)\n#\n#    dx = (x_max - x_min) / (width - 1)\n#    dy = (y_max - y_min) / (height - 1)\n#\n#    inv_log2 = 1.0 / math.log(2.0)   # for nu calculation\n#\n#    for j in prange(height):\n#        zy = y_min + j * dy\n#        for i in range(width):\n#            zx = x_min + i * dx\n#            zr = 0.0\n#            zi = 0.0\n#            cr = zx\n#            ci = zy\n#            iteration = 0\n#            min_cross = 1e10\n#\n#            # Mandelbrot iteration\n#            while iteration &lt; max_iter:\n#                # TODO : use zr * zr + zi * zi &lt;= 4 and iteration &lt; max_iter for classical fractal calculation without orbit traps\n#                # (zr + i zi)^2 + c\n#                zr2 = zr * zr - zi * zi + cr\n#                zi = 2.0 * zr * zi + ci\n#                zr = zr2\n#                iteration += 1\n#\n#                # Cross trap: distance to real or imaginary axis\n#                # TOTO : only take the min after a specific number of iterations , e. g. iteration &gt; 3:\n#                if iteration &gt; 2:\n#                    cross_dist = min(abs(zr), abs(zi))\n#                    if (cross_dist &lt; min_cross):\n#                        min_cross = cross_dist\n#\n#            cross_trap[j, i] = min_cross\n#\n#    return cross_trap\n#\n#class MandelbrotCrossTrap(Fractal):\n#    def compute(self) -&gt; np.ndarray:\n#        w, h = self.resolution\n#        # pass resolution-consistent dims\n#        return _compute_mandelbrot_cross_trap(self._x_min, self._x_max, self._y_min, self._y_max, w, h, self._max_iter)\n\n\n##| export\n#@njit(parallel=True, fastmath=True)\n#def _compute_julia_set(xmin, xmax, ymin, ymax, width, height, cr, ci, max_iter):\n#    dx = (xmax - xmin) / (width - 1)\n#    dy = (ymax - ymin) / (height - 1)\n#    result = np.zeros((height, width), dtype=np.float32)\n#\n#    for j in prange(height):\n#        y0 = ymin + j * dy\n#        for i in range(width):\n#            x0 = xmin + i * dx\n#            x = x0\n#            y = y0\n#            iteration = 0\n#            while x*x + y*y &lt;= 6.25 and iteration &lt; max_iter:\n#                x_temp = x*x - y*y + cr\n#                y = 2.0 * x * y + ci\n#                x = x_temp\n#                iteration += 1\n#\n#            if iteration &lt; max_iter:\n#                # Smooth coloring\n#                modulus_sq = x*x + y*y\n#                log_zn = np.log(modulus_sq) / 2\n#                nu = np.log(log_zn / np.log(2)) / np.log(2)\n#                result[j, i] = iteration + 1 - nu\n#            else:\n#                result[j, i] = max_iter\n#\n#    return result\n#\n#class Julia(Fractal):\n#    def __init__(\n#        self,\n#        cr: float = -0.7,\n#        ci: float = 0.27015,\n#        width: int = 800,\n#        height: int = 800,\n#        x_min: float = -1.5,   # override Fractal default\n#        x_max: float =  1.5,   # override Fractal default\n#        y_min: float = -1.5,   # keep same (or change)\n#        y_max: float =  1.5,   # keep same (or change)\n#        max_iter: int = 1000,  # keep same (or change)\n#    ):\n#        # 1) initialize the Fractal portion:\n#        super().__init__(width, height, x_min, x_max, y_min, y_max, max_iter)\n#\n#        # 2) store Julia‐specific constants\n#        self._cr = cr\n#        self._ci = ci\n#        \n#    def compute(self) -&gt; np.ndarray:\n#        w, h = self.resolution\n#        # pass resolution-consistent dims\n#        return _compute_julia_set(self._x_min, self._x_max, self._y_min, self._y_max, w, h, self._cr, self._ci, self._max_iter)\n\n\n#j = Julia(cr = -0.7, ci = 0.27015)\n#j.resolution = 1200, 1200\n#j.max_iter = 3000\n#j.render()\n#j.equalize_histogram()\n#j.plot()\n\n\n##| export\n#@njit(parallel=True, fastmath=True)\n#def _compute_julia_cross_trap(xmin, xmax, ymin, ymax, width, height, cr, ci, max_iter):\n#    dx = (xmax - xmin) / (width - 1)\n#    dy = (ymax - ymin) / (height - 1)\n#    cross_trap = np.zeros((height, width), dtype=np.float32)\n#\n#    for j in prange(height):\n#        y0 = ymin + j * dy\n#        for i in range(width):\n#            x0 = xmin + i * dx\n#            x = x0\n#            y = y0\n#            iteration = 0\n#            min_cross = 1e10\n#            \n#            while iteration &lt; max_iter:\n#                x_temp = x*x - y*y + cr\n#                y = 2.0 * x * y + ci\n#                x = x_temp\n#                iteration += 1\n#\n#                # Cross trap: distance to real or imaginary axis\n#                # TOTO : only take the min after a specific number of iterations , e. g. iteration &gt; 3:\n#                if iteration &gt; -1:\n#                    cross_dist = min(abs(x), abs(y))\n#                    if (cross_dist &lt; min_cross):\n#                        min_cross = cross_dist\n#\n#            cross_trap[j, i] = min_cross\n#\n#    return cross_trap\n#\n#class JuliaCrossTrap(Fractal):\n#    def __init__(\n#        self,\n#        cr: float = -0.7,\n#        ci: float = 0.27015,\n#        width: int = 800,\n#        height: int = 800,\n#        x_min: float = -1.5,   # override Fractal default\n#        x_max: float =  1.5,   # override Fractal default\n#        y_min: float = -1.5,   # keep same (or change)\n#        y_max: float =  1.5,   # keep same (or change)\n#        max_iter: int = 1000,  # keep same (or change)\n#    ):\n#        # 1) initialize the Fractal portion:\n#        super().__init__(width, height, x_min, x_max, y_min, y_max, max_iter)\n#\n#        # 2) store Julia‐specific constants\n#        self._cr = cr\n#        self._ci = ci\n#        \n#    def compute(self) -&gt; np.ndarray:\n#        w, h = self.resolution\n#        # pass resolution-consistent dims\n#        return _compute_julia_cross_trap(self._x_min, self._x_max, self._y_min, self._y_max, w, h, self._cr, self._ci, self._max_iter)\n\n\n#j = JuliaCrossTrap(cr = 0.355, ci = 0.355)\n#j.resolution = 1200, 1200\n#j.max_iter = 3000\n#j.render()\n#j.equalize_histogram()\n#j.plot()\n\n\n#j = Julia(cr = -0.4, ci = 0.6)\n#j.resolution = 1200, 1200\n#j.max_iter = 3000\n#j.render()\n#j.equalize_histogram()\n#j.plot()\n\n\n#j = Julia(cr = -0.8, ci = 0.156)\n#j.resolution = 1200, 1200\n#j.max_iter = 3000\n#j.render()\n#j.equalize_histogram()\n#j.plot()\n\n\n#m = Mandelbrot()\n#m.resolution = 1200, 1200\n#m.max_iter = 3000\n#m.set_zoom(1, (0.0, 0.0))\n#m.render()\n#m.equalize_histogram()\n#m.plot()\n\n\n#m = MandelbrotCrossTrap()\n#m.resolution = 1200, 1200\n#m.max_iter = 3000\n#m.set_zoom(2, (0.0, 0.0))\n#m.render()\n#m.equalize_histogram()\n#m.plot()\n\n\n#m = MandelbrotCrossTrap()\n#m.resolution = 1200, 1200\n#m.max_iter = 3000\n#\n##m.set_zoom(5, (-0.170337,-1.06506))\n##m.set_zoom(25, (-0.170337,-1.06506))\n##m.set_zoom(125, (-0.170337,-1.06506))\n##m.set_zoom(625, (-0.170337,-1.06506))\n##m.set_zoom(3125, (-0.170337,-1.06506))\n##m.set_zoom(15625, (-0.170337,-1.06506))\n##m.set_zoom(78125, (-0.170337,-1.06506))\n#\n##m.set_zoom(5, (0.42884,-0.231345))\n##m.set_zoom(25, (0.42884,-0.231345))\n#m.set_zoom(125, (0.42884,-0.231345))\n##m.set_zoom(625, (0.42884,-0.231345))\n##m.set_zoom(3125, (0.42884,-0.231345))\n##m.set_zoom(15625, (0.42884,-0.231345))\n##m.set_zoom(78125, (0.42884,-0.231345))\n#\n##m.set_zoom(5, (-1.62917,-0.0203968))\n##m.set_zoom(25, (-1.62917,-0.0203968))\n##m.set_zoom(125, (-1.62917,-0.0203968))\n##m.set_zoom(625, (-1.62917,-0.0203968))\n##m.set_zoom(3125, (-1.62917,-0.0203968))\n##m.set_zoom(15625, (-1.62917,-0.0203968))\n##m.set_zoom(78125, (-1.62917,-0.0203968))\n#\n##m.set_zoom(5, (-0.761574,-0.0847596))\n##m.set_zoom(25, (-0.761574,-0.0847596))\n##m.set_zoom(125, (-0.761574,-0.0847596))\n##m.set_zoom(625, (-0.761574,-0.0847596))\n##m.set_zoom(3125, (-0.761574,-0.0847596))\n##m.set_zoom(15625, (-0.761574,-0.0847596))\n##m.set_zoom(78125, (-0.761574,-0.0847596))\n#\n#m.render()\n#m.equalize_histogram()\n#m.plot()",
    "crumbs": [
      "fractals",
      "newton"
    ]
  },
  {
    "objectID": "fractals/abstract_fractal.html",
    "href": "fractals/abstract_fractal.html",
    "title": "fractal",
    "section": "",
    "text": "source\n\nFractal\n\n Fractal (width:int=1200, height:int=1200)\n\nAbstract base class for generating fractal images.",
    "crumbs": [
      "fractals",
      "fractal"
    ]
  }
]